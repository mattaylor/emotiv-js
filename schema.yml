- title: Headset
  description: An EEG Headset
  type: object
  properties: &headset
    id: { title: 'BT serial id', pattern: '(INSIGHT | EPOC)-\w{8}' }
    label: { title: 'user supplied headset name', faker: commerce.product }
    iface: { enum: [BTLE, DONGLE] }
    dongle: { pattern: 'U\d{8}', notes: 'Dongle serial Id'}
    status: { enum: [ CONNECTED, DISCONNECTED, INUSE ] }
    serial: { type: string, faker: random.uuid }
    hardware: { type: string, notes: Hardware version, faker: system.semver }
    firmware: { pattern: 'v\d\.\d{2}', notes: 'Firmware version', faker: system.semver }
    sensors: { type: array, items: { pattern: '\w{2}', notes: EEG Sensor Names } }
    settings: 
      type: object
      properties: 
        mode: { enum: [EPOC, EPOC+] }
        eegRate:  { enum: [0, 64, 128, 256 ] }
        eegRes:   { enum: [16, 14] }
        memsRate: { enum: [0, 64, 128, 256 ] }
        memsRes:  { enum: [16, 14] }

- title: Stream
  description: | 
    Configuration Details for a Notification Stream
  type: object
  properties: &stream
    open: { type: boolean, default: true } 
    cols: { type: array, minItems: 4, items: { faker: hacker.abbreviation } } 
    spec: { type: array, items: { enum: [ enum, unit, word, uint, pcts, time] } }
    freq: { type: integer, minimum: 1, maximum: 256, notes: 'Expected Update Frequency' }
    unit: { type: string, enum: [Hz, Mv, Pct], notes: 'Unit for unit values' }
    enums: { type: array,  items: { type: string, faker: random.word }, 'Enumeration labels for enum cols' } 

- title: Session
  description: | 
    Represents an continuous period of eeg related activity using an emotive headset.
  required: [id]
  properties: 
    id: { pattern: 'w{4}.\d{8}', notes: 'Session GUID', faker: random.uuid }
    label:   { faker: random.word }
    status:  { enum: [ready, active, error, closed] }
    subject: { pattern: '\w{4}', notes: Emotiv Subject Id }
    license: { pattern: '\w{8}', notes: License used to create session }
    profile: { pattern: '\w{8}', notes: Profile used for commands / facials detections }
    headset: { type: string, faker: random.uuid }
    client:  { pattern: '\w{8}', faker: commerce.productName, notes: Client Application Identifier }
    started: { type: string, format: date-time,  faker: date.recent, notes: Session start time }
    stopped: { type: string, format: date-time,  faker: date.recent, notes: Session stop  time }
    markers: { type: array,  items: { type: string,  faker: hacker.ingverb }, notes: Labels for Event Markers }
    streams:   
      type: object
      required: [eeg,cog,mot,dev,pro,fac,con,com]
      properties: 
        pro: *stream
        cog: *stream
        mot: *stream
        fac: *stream
        com: *stream
        eeg: *stream
        dev: *stream
        con: *stream
    tags: { type: array, items: { type: string, faker: hacker.adjective }, notes: Tags for this session }
    logs: 
      type: array
      notes: Event Log file names for each 10 sec window 
      items: { pattern: '(eegs|perf|gyro|comm|face|cont)\:\d{4}' }
   
- title: Profile
  description: |
    Training Profiles for Mental Commands and facial expressions.
  properties:
    id: { pattern: '\w{8}.\d', notes: '{emotivId}/{index}' }
    type : { pattern: profile }
    label: { type: string, notes: Profile name, faker: name.jobType }
    subject: { pattern: 'sub:\w{8}', notes: The Subject ID the  created this profile }
    command: 
      patternProperties:
        (push|pull|moveR|moveL|moveU|moveD|neutral): &action 
          type: object 
          properties:
            label : { type: string, faker: hacker.verb  }
            index : { type: integer, minimum: 0, maximum: 6 }
            status: { enum: [training, completed, untrained ] }
            rating: { type: integer, minimum: 0, maximum: 100, notes: Skill Rating }
    faceExp: 
      patternProperties: 
        (lookR|lookL|frown|smile|suprise|open|closed|neutral): *action 
    tags: { type: array, items: { pattern: '\w{8}', faker: hacker.noun } }
    logs: { type: array, items: { items: { pattern: '(com|fac)\:\w{4}' } } }
   
- title: Subject
  description: A Unique end user. 'Sub' users can be created on a parent emoId account by prefixing the sub user 'emoId' with the emoId of the parent followed by a '/'
  properties:
    id: { pattern: '\w{8}(/\w{8})?', notes: '{emotivId}/{name}' }
    type: { pattern: subject }
    owner: { type: string, notes: "Emotiv ID", faker: internet.userName }
    name: { type: string, faker: name.findName }
    tags: { type: array, items: { pattern: '\w{8}', faker: name.jobDescriptor } }
    meta: { type: object }

- title: Message
  description: A Sample even Unique end user. 'Sub' users can be created on a parent emoId account by prefixing the sub user 'emoId' with the emoId of the parent followed by a '/'
  properties:
    sid:   { pattern: '\w{8}', faker: random.uuid, notres: Session/Subscription Id }
    time: { type: string,  format: date-time, faker: date.recent }
    eeg: { type: array, items: { type: integer, minimum: 0, maximum: 1000, faker: finance.amount }, length: 6, notes: EEG Data Samples }
    cog: { type: array, items: { type: integer, minimum: 0, maximum: 1000, faker: finance.amount }, length: 6, notes: Performance Metrics }
    con: { type: array, items: { type: integer, minimum: 0, maximum: 1000, faker: finance.amount }, length: 8, notes: Contact Quality }
    dev: { type: array, items: { type: integer, minimum: 0, maximum: 1000, faker: finance.amount }, length: 2,  notes: Device Status }
    pro: { type: array, items: [ { type: integer, minimum: 0, maximum: 10 }, { enum: [started, completed ] } ], notes: Profile Trainging }
    mot: { type: array, items: { type: integer, minimum: 0, maximum: 100, faker: finance.amount }, length: 6,  notes: Motion sensors }
    pow: { type: array, items: { type: integer, minimum: 0, maximum: 100, faker: finance.amount }, length: 6,  notes: Band Powers }
    
- title: License
  description: |
    A License to use cortex / sdk.
  type: object
  properties:
    id: { pattern: '\w{8}', notes: 'License key' }
    type: { pattern: license }
    label :  { notes: 'Optional User defined license name', type: string }
    scope  : { type: array, items: { enum: [pm, eeg, test ] } }
    owner  : { notes: License Owner EmoID, faker: internet.userName }
    clients: { type: array, items: { type: string, faker: commerce.productName },  notes: If defined client must be a member of this set }
    userIds: { type: array, items: { type: string, faker: internet.userName },  notes: If defined userId must be a member of this set }
    secret : { type: string, faker: hacker.phrase,  notes: Optional Secret that may be used to sign auth requests as SHA256 HMAC }
    balance: { type: integer, faker: finance.amount, notes: Available Session Balance }
    maxDevices: { type: integer, default: 3,  faker: finance.amount, notes: Maximum Devices allowed - default is amount / 10 ) }
    dailyLimit: { type: integer, default: 10, faker: finance.amount, notes: Maximum Debit per User per Day  }
    expires: { type: string, format: date-time, faker: date.future, notes: Expiration Date of current billing period } 
    devices: { type: array, items: { faker: random.uuid },  title: Current Devices Using License }
    initial: { type: integer, faker: finance.amount,   notes: Initial balance purchased with subscription  } 
    topups : { type: integer, faker: finance.amount, title:  Additonal topup sessions, (Unused TopUps roll over to next billing period }
    status : { enum: [active, suspended, expired, pending ] }
    period : { type: integer, notes: Billing period in days }

- title: AuthRequest
  description: |
    Authorize Request
  type: object
  required: [license]
  properties: 
    license:  { pattern: '[A-Za-z0-9]{10}' }
    username: { pattern: '[A-Za-z0-9]{10}', faker: internet.userName }
    password: { pattern: '[A-Za-z0-9]{10}', faker: internet.password }
    debit:    { type: integer, minimum: 0, maximum: 100 }
    client:   { type: string, faker: commerce.productName }
    timestamp: { type: string, format: date-time, faker: date.recent }
    _hash:    { type: 'string', chance: hash }


- title: AuthResponse
  description: |
    Authorize Response
  type: object
  properties: 
    _auth:   { type: string, length: 8, faker: internet.password }
    scope:   { type: array, items: { enum: [eeg, pm, debug, cloud] } }
    expires: { type: string, format: dat-time, faker: date.future } 
    balance: { type: integer, minimum: 0, maximum: 100 }
